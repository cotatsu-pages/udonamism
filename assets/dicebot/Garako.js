/* Generated by Opal 1.0.3 */
Opal.modules["utils/table"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$freeze', '$match', '$raise', '$to_i', '$[]', '$roll', '$-']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Table');

    var $nesting = [self].concat($parent_nesting), $Table_initialize$1, $Table_roll$2;

    self.$$prototype.times = self.$$prototype.sides = self.$$prototype.name = self.$$prototype.items = nil;
    
    
    Opal.def(self, '$initialize', $Table_initialize$1 = function $$initialize(name, type, items) {
      var self = this, m = nil;

      
      self.name = name;
      self.items = items.$freeze();
      m = /(\d+)D(\d+)/i.$match(type);
      if ($truthy(m)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + "Unexpected table type: " + (type))
      };
      self.times = m['$[]'](1).$to_i();
      return (self.sides = m['$[]'](2).$to_i());
    }, $Table_initialize$1.$$arity = 3);
    return (Opal.def(self, '$roll', $Table_roll$2 = function $$roll(bcdice) {
      var $a, $b, self = this, value = nil, index = nil;

      
      $b = bcdice.$roll(self.times, self.sides), $a = Opal.to_ary($b), (value = ($a[0] == null ? nil : $a[0])), $b;
      index = $rb_minus(value, self.times);
      return "" + (self.name) + "(" + (value) + ") ＞ " + (self.items['$[]'](index));
    }, $Table_roll$2.$$arity = 1), nil) && 'roll';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["utils/range_table"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$new', '$alias_method', '$freeze', '$lambda', '$name', '$sum', '$content', '$attr_reader', '$match', '$raise', '$to_i', '$[]', '$store', '$find', '$include?', '$range', '$roll', '$map', '$split', '$to_proc', '$fetch', '$formatted=', '$-', '$private', '$coerce_to_int_range', '$sort_by', '$min', '$assert_min_sum_is_covered', '$assert_max_sum_is_covered', '$assert_no_gap_or_overlap_in_ranges', '$===', '$is_a?', '$begin', '$end', '$class', '$first', '$*', '$last', '$each_cons', '$max', '$+']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'RangeTable');

    var $nesting = [self].concat($parent_nesting), $RangeTable$1, $RangeTable$2, $RangeTable_initialize$3, $RangeTable_fetch$4, $RangeTable_roll$6, $RangeTable_store$7, $RangeTable_coerce_to_int_range$11, $RangeTable_assert_min_sum_is_covered$12, $RangeTable_assert_max_sum_is_covered$13, $RangeTable_assert_no_gap_or_overlap_in_ranges$14;

    self.$$prototype.name = self.$$prototype.items = self.$$prototype.num_of_dice = self.$$prototype.num_of_sides = self.$$prototype.formatter = nil;
    
    Opal.const_set($nesting[0], 'RollResult', $send($$($nesting, 'Struct'), 'new', ["sum", "values", "content", "formatted"], ($RangeTable$1 = function(){var self = $RangeTable$1.$$s || this;

    return self.$alias_method("to_s", "formatted")}, $RangeTable$1.$$s = self, $RangeTable$1.$$arity = 0, $RangeTable$1)));
    Opal.const_set($nesting[0], 'Item', $$($nesting, 'Struct').$new("range", "content"));
    Opal.const_set($nesting[0], 'DICE_ROLL_METHOD_RE', /^(\d+)D(\d+)$/i.$freeze());
    Opal.const_set($nesting[0], 'DEFAULT_FORMATTER', $send(self, 'lambda', [], ($RangeTable$2 = function(table, result){var self = $RangeTable$2.$$s || this;

    
      
      if (table == null) {
        table = nil;
      };
      
      if (result == null) {
        result = nil;
      };
      return "" + (table.$name()) + "(" + (result.$sum()) + ") ＞ " + (result.$content());}, $RangeTable$2.$$s = self, $RangeTable$2.$$arity = 2, $RangeTable$2)));
    self.$attr_reader("name");
    self.$attr_reader("num_of_dice");
    self.$attr_reader("num_of_sides");
    
    Opal.def(self, '$initialize', $RangeTable_initialize$3 = function $$initialize(name, dice_roll_method, items) {
      var $iter = $RangeTable_initialize$3.$$p, formatter = $iter || nil, $a, self = this, m = nil;

      if ($iter) $RangeTable_initialize$3.$$p = null;
      
      
      if ($iter) $RangeTable_initialize$3.$$p = null;;
      self.name = name.$freeze();
      self.formatter = ($truthy($a = formatter) ? $a : $$($nesting, 'DEFAULT_FORMATTER'));
      m = $$($nesting, 'DICE_ROLL_METHOD_RE').$match(dice_roll_method);
      if ($truthy(m)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + (self.name) + ": invalid dice roll method: " + (dice_roll_method))
      };
      self.num_of_dice = m['$[]'](1).$to_i();
      self.num_of_sides = m['$[]'](2).$to_i();
      return self.$store(items);
    }, $RangeTable_initialize$3.$$arity = 3);
    
    Opal.def(self, '$fetch', $RangeTable_fetch$4 = function $$fetch(value) {
      var $$5, self = this, item = nil;

      
      item = $send(self.items, 'find', [], ($$5 = function(i){var self = $$5.$$s || this;

      
        
        if (i == null) {
          i = nil;
        };
        return i.$range()['$include?'](value);}, $$5.$$s = self, $$5.$$arity = 1, $$5));
      if ($truthy(item)) {
      } else {
        self.$raise($$($nesting, 'RangeError'), "" + (self.name) + ": value is out of range: " + (value))
      };
      return item;
    }, $RangeTable_fetch$4.$$arity = 1);
    
    Opal.def(self, '$roll', $RangeTable_roll$6 = function $$roll(bcdice) {
      var $a, $b, self = this, sum = nil, values_str = nil, values = nil, result = nil, $writer = nil;

      
      $b = bcdice.$roll(self.num_of_dice, self.num_of_sides), $a = Opal.to_ary($b), (sum = ($a[0] == null ? nil : $a[0])), (values_str = ($a[1] == null ? nil : $a[1])), $b;
      values = $send(values_str.$split(","), 'map', [], "to_i".$to_proc());
      result = $$($nesting, 'RollResult').$new(sum, values, self.$fetch(sum).$content());
      
      $writer = [self.formatter['$[]'](self, result)];
      $send(result, 'formatted=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      return result;
    }, $RangeTable_roll$6.$$arity = 1);
    self.$private();
    
    Opal.def(self, '$store', $RangeTable_store$7 = function $$store(items) {
      var $$8, $$9, $$10, self = this, items_with_range = nil, sorted_items = nil;

      
      items_with_range = $send(items, 'map', [], ($$8 = function(r, c){var self = $$8.$$s || this;

      
        
        if (r == null) {
          r = nil;
        };
        
        if (c == null) {
          c = nil;
        };
        return [self.$coerce_to_int_range(r), c];}, $$8.$$s = self, $$8.$$arity = 2, $$8));
      sorted_items = $send(items_with_range, 'sort_by', [], ($$9 = function(r, _){var self = $$9.$$s || this;

      
        
        if (r == null) {
          r = nil;
        };
        
        if (_ == null) {
          _ = nil;
        };
        return r.$min();}, $$9.$$s = self, $$9.$$arity = 2, $$9));
      self.$assert_min_sum_is_covered(sorted_items);
      self.$assert_max_sum_is_covered(sorted_items);
      self.$assert_no_gap_or_overlap_in_ranges(sorted_items);
      self.items = $send(sorted_items, 'map', [], ($$10 = function(range, content){var self = $$10.$$s || this;

      
        
        if (range == null) {
          range = nil;
        };
        
        if (content == null) {
          content = nil;
        };
        return $$($nesting, 'Item').$new(range, content.$freeze()).$freeze();}, $$10.$$s = self, $$10.$$arity = 2, $$10)).$freeze();
      return self;
    }, $RangeTable_store$7.$$arity = 1);
    
    Opal.def(self, '$coerce_to_int_range', $RangeTable_coerce_to_int_range$11 = function $$coerce_to_int_range(x) {
      var $a, self = this, $case = nil;

      
      $case = x;
      if ($$($nesting, 'Integer')['$===']($case)) {return $$($nesting, 'Range').$new(x, x)}
      else if ($$($nesting, 'Range')['$===']($case)) {if ($truthy(($truthy($a = x.$begin()['$is_a?']($$($nesting, 'Integer'))) ? x.$end()['$is_a?']($$($nesting, 'Integer')) : $a))) {
        return x}};
      return self.$raise($$($nesting, 'TypeError'), "" + (self.name) + ": " + (x) + " (" + (x.$class()) + ") must be an Integer or a Range with Integers ");
    }, $RangeTable_coerce_to_int_range$11.$$arity = 1);
    
    Opal.def(self, '$assert_min_sum_is_covered', $RangeTable_assert_min_sum_is_covered$12 = function $$assert_min_sum_is_covered(sorted_items) {
      var self = this, min_sum = nil, range = nil;

      
      min_sum = self.num_of_dice;
      range = sorted_items.$first()['$[]'](0);
      if ($truthy(range['$include?'](min_sum))) {
      } else {
        self.$raise($$($nesting, 'RangeError'), "" + (self.name) + ": min value (" + (min_sum) + ") is not covered: " + (range))
      };
      return self;
    }, $RangeTable_assert_min_sum_is_covered$12.$$arity = 1);
    
    Opal.def(self, '$assert_max_sum_is_covered', $RangeTable_assert_max_sum_is_covered$13 = function $$assert_max_sum_is_covered(sorted_items) {
      var self = this, max_sum = nil, range = nil;

      
      max_sum = $rb_times(self.num_of_dice, self.num_of_sides);
      range = sorted_items.$last()['$[]'](0);
      if ($truthy(range['$include?'](max_sum))) {
      } else {
        self.$raise($$($nesting, 'RangeError'), "" + (self.name) + ": max value (" + (max_sum) + ") is not covered: " + (range))
      };
      return self;
    }, $RangeTable_assert_max_sum_is_covered$13.$$arity = 1);
    return (Opal.def(self, '$assert_no_gap_or_overlap_in_ranges', $RangeTable_assert_no_gap_or_overlap_in_ranges$14 = function $$assert_no_gap_or_overlap_in_ranges(sorted_items) {
      var $$15, self = this;

      
      $send(sorted_items, 'each_cons', [2], ($$15 = function(i1, i2){var self = $$15.$$s || this, r1 = nil, r2 = nil, max1 = nil, next_of_max1 = nil;
        if (self.name == null) self.name = nil;

      
        
        if (i1 == null) {
          i1 = nil;
        };
        
        if (i2 == null) {
          i2 = nil;
        };
        r1 = i1['$[]'](0);
        r2 = i2['$[]'](0);
        max1 = r1.$max();
        next_of_max1 = $rb_plus(max1, 1);
        if ($truthy(r2['$include?'](max1))) {
          self.$raise($$($nesting, 'RangeError'), "" + (self.name) + ": Range overlap: " + (r1) + " and " + (r2))};
        if ($truthy(r2['$include?'](next_of_max1))) {
          return nil
        } else {
          return self.$raise($$($nesting, 'RangeError'), "" + (self.name) + ": Range gap: " + (r1) + " and " + (r2))
        };}, $$15.$$s = self, $$15.$$arity = 2, $$15));
      return self;
    }, $RangeTable_assert_no_gap_or_overlap_in_ranges$14.$$arity = 1), nil) && 'assert_no_gap_or_overlap_in_ranges';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["utils/format"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $module = Opal.module, $truthy = Opal.truthy;

  Opal.add_stubs(['$module_function', '$===', '$to_s', '$==', '$>']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Format');

    var $nesting = [self].concat($parent_nesting), $Format_comparison_operator$1, $Format_modifier$2;

    
    self.$module_function();
    
    Opal.def(self, '$comparison_operator', $Format_comparison_operator$1 = function $$comparison_operator(op) {
      var self = this, $case = nil;

      return (function() {$case = op;
      if ("=="['$===']($case)) {return "="}
      else if ("!="['$===']($case)) {return "<>"}
      else if ($$($nesting, 'Symbol')['$===']($case)) {return op.$to_s()}
      else { return nil }})()
    }, $Format_comparison_operator$1.$$arity = 1);
    
    Opal.def(self, '$modifier', $Format_modifier$2 = function $$modifier(number) {
      var self = this;

      if (number['$=='](0)) {
        return ""
      } else if ($truthy($rb_gt(number, 0))) {
        return "" + "+" + (number)
      } else {
        return number.$to_s()
      }
    }, $Format_modifier$2.$$arity = 1);
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.0.3 */
(function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $range = Opal.range;

  Opal.add_stubs(['$require', '$roll_tables', '$roll_gr', '$roll_damage_chart', '$private', '$match', '$to_i', '$[]', '$roll', '$+', '$==', '$>=', '$modifier', '$to_s', '$join', '$clamp', '$-', '$<', '$>', '$freeze', '$new', '$setPrefixes', '$keys']);
  
  self.$require("utils/table");
  self.$require("utils/range_table");
  self.$require("utils/format");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Garako');

    var $nesting = [self].concat($parent_nesting), $Garako_rollDiceCommand$1, $Garako_roll_gr$2, $Garako_roll_damage_chart$3, $Garako_clamp$4;

    
    Opal.const_set($nesting[0], 'ID', "Garako");
    Opal.const_set($nesting[0], 'NAME', "ガラコと破界の塔");
    Opal.const_set($nesting[0], 'SORT_KEY', "からことはかいのとう");
    Opal.const_set($nesting[0], 'HELP_MESSAGE', "" + "・判定\n" + "GR+n>=X：「+n」で判定値を指定、「X」で目標値を指定。\n" + "・部位決定チャート：HIT\n" + "・ダメージチャート：xDCy（CDC/EDC/FDC/ADC/LDC)\n" + "　xは C：コックピット、E：エンジン、F：フレーム、A：アーム、L：レッグ\n" + "　yはダメージ値\n" + "各種表\n" + "・個性表：IDI／動機決定表：MTV\n" + "・名前表\n" + "ピグマー族　　男：PNM　女：PNF　　エレメント族　男：ENM　女：ENF\n" + "ノーマッド族　男：NNM　女：NNF　　ラット族　　　男：RNM　女：RNF\n" + "ブレイン族　　１：BN1　２：BN2　　テンタクル族　１：TN1　２：TN2\n" + "・ガラコ改造チャート表：GCC\n" + "・武器改造チャート表：WCC\n" + "・イベントチャート表：EVC\n" + "・戦闘開始距離：BSD\n");
    
    Opal.def(self, '$rollDiceCommand', $Garako_rollDiceCommand$1 = function $$rollDiceCommand(command) {
      var $a, $b, self = this;

      return ($truthy($a = ($truthy($b = self.$roll_tables(command, $$($nesting, 'TABLES'))) ? $b : self.$roll_gr(command))) ? $a : self.$roll_damage_chart(command))
    }, $Garako_rollDiceCommand$1.$$arity = 1);
    self.$private();
    
    Opal.def(self, '$roll_gr', $Garako_roll_gr$2 = function $$roll_gr(command) {
      var $a, $b, self = this, m = nil, modify_number = nil, target_number = nil, dice = nil, total = nil, result = nil, formated_modifier = nil, sequence = nil;

      
      m = /^GR([+-]\d+)?>=(\d+)$/i.$match(command);
      if ($truthy(m)) {
      } else {
        return nil
      };
      modify_number = m['$[]'](1).$to_i();
      target_number = m['$[]'](2).$to_i();
      $b = self.$roll(1, 10), $a = Opal.to_ary($b), (dice = ($a[0] == null ? nil : $a[0])), $b;
      total = $rb_plus(dice, modify_number);
      result = (function() {if (dice['$=='](1)) {
        return "ファンブル"
      } else if (dice['$=='](10)) {
        return "クリティカル"
      } else if ($truthy($rb_ge(total, target_number))) {
        return "成功"
      } else {
        return "失敗"
      }; return nil; })();
      formated_modifier = $$($nesting, 'Format').$modifier(modify_number);
      sequence = ["" + "(1D10" + (formated_modifier) + ">=" + (target_number) + ")", "" + (dice) + "[" + (dice) + "]" + (formated_modifier), total.$to_s(), result];
      return sequence.$join(" ＞ ");
    }, $Garako_roll_gr$2.$$arity = 1);
    
    Opal.def(self, '$roll_damage_chart', $Garako_roll_damage_chart$3 = function $$roll_damage_chart(command) {
      var self = this, m = nil, part = nil, damage = nil, index = nil, chart = nil, chosen = nil;

      
      m = /^(\wDC)(\d+)$/i.$match(command);
      if ($truthy(m)) {
      } else {
        return nil
      };
      part = m['$[]'](1);
      damage = self.$clamp(m['$[]'](2).$to_i(), 1, 10);
      index = $rb_minus(damage, 1);
      chart = $$($nesting, 'DAMAGE_CHARTS')['$[]'](part);
      if ($truthy(chart)) {
      } else {
        return nil
      };
      chosen = chart['$[]']("table")['$[]'](index);
      return "" + (chart['$[]']("name")) + "(" + (damage) + ") ＞ " + (chosen);
    }, $Garako_roll_damage_chart$3.$$arity = 1);
    
    Opal.def(self, '$clamp', $Garako_clamp$4 = function $$clamp(i, min, max) {
      var self = this;

      if ($truthy($rb_lt(i, min))) {
        return min
      } else if ($truthy($rb_gt(i, max))) {
        return max
      } else {
        return i
      }
    }, $Garako_clamp$4.$$arity = 3);
    Opal.const_set($nesting[0], 'DAMAGE_CHARTS', $hash2(["CDC", "EDC", "FDC", "ADC", "LDC"], {"CDC": $hash2(["name", "table"], {"name": "部位ダメージチャート：コックピット", "table": ["小破（アーマー損傷）：以後、この部位の【部位装甲】-1。", "小破（視界不良）：モニターやハッチの歪み等により、視界を大きく遮られる。以後、【視認性】-1、【部位装甲】-1。", "小破（強震）：大きく揺さぶられる。キミは【身体】10の判定を行う。失敗した場合、次のターンを失う。【部位装甲】-1。", "小破（収納直撃）：アイテム収納スペースに直撃！　所持品一つにつき1d10を振れ。出目が5以下だった所持品は破壊される。【部位装甲】-1。", "中破（計器損傷）：コンソールの一部が停止する。［弱体1］を受ける。", "中破（制御不能）：コントロールが効かなくなる。キミは次のターンを失う。［弱体1］を受ける。", "中破（貫通！）：パイロットに被害が！　キミはHPダメージ（1d10-【身体】）に加え、［弱体1］を受ける。", "大破（故障）：コックピットが完全にいかれる。キミは次のラウンド終了時まで、あらゆる判定に自動的にファンブルする。［弱体1］を受ける。", "大破（貫通！）：パイロットに被害が！　キミはHPダメージ（1d10+3-【身体】）に加え、［弱体1］を受ける。", "修復不能（破壊）：コックピットが［修復不能］となる。キミは2d10-【身体】点のHPダメージを受ける。ガラコはすべての機能を停止する。コックピットのハッチが自動的に開く。"]}), "EDC": $hash2(["name", "table"], {"name": "部位ダメージチャート：エンジン", "table": ["小破（アーマー損傷）：以後、この部位の【部位装甲】-1。", "小破（アーマー損傷）：以後、この部位の【部位装甲】-1。", "小破（燃料漏れ）：タンクから燃料が漏れる。燃料-1。この部位の【部位装甲】-1。", "小破（燃料漏れ）：タンクから燃料が漏れる。燃料-2。この部位の【部位装甲】-1。", "中破（エンジン不調）：時々エンジンが動かなくなる。［弱体1］を受ける。", "中破（燃料漏れ）：タンクから燃料が漏れる。燃料-2。［弱体1］を受ける。", "中破（ヒート）：オーバーヒートする。次のターンの終了時まで、移動と攻撃を行えない。［弱体1］を受ける。", "大破（エンジン不調）：キミは次のターンを失う。［弱体1］を受ける。", "大破（故障）：以後、この部位の【部位装甲】が0になる。［弱体1］を受ける。", "修復不能（エンジン停止）：エンジンが停止する。ガラコはすべての機能を停止する。コックピットのハッチが自動的に開く。【操作性】10の判定を行うこと。失敗するとエンジンが爆発する。その場合、すべての部位が［修復不能］となり、キミは2d10-【身体】点のダメージを受ける。"]}), "FDC": $hash2(["name", "table"], {"name": "部位ダメージチャート：フレーム", "table": ["小破（不安定）：体勢を崩す。次のターン、キミは攻撃を行えない。この部位の【部位装甲】-1。", "小破（スクラッチ！）：フレームに醜い傷が残る。この部位の【部位装甲】-1。", "小破（アーマー損傷）：フレームが歪む。この部位の【部位装甲】-1。", "小破（アーマー損傷）：フレームがきしみ始め、ガラコの動きを阻害し始める。【移動力】-1。さらに、この部位の【部位装甲】-1。", "中破（放熱板損傷）：熱を機体外に逃すことができなくなる。［弱体1］を受ける。", "中破（スタビライザー損傷）：機体のバランス調整装置が故障する。【身体】10の判定を行うこと。失敗した場合、キミは次のターンを失う。［弱体1］を受ける。", "中破（貫通！）：パイロットに被害が！　キミはHPダメージ（1d10-【身体】）を受ける。［弱体1］を受ける。", "大破（停止）：フレームが動かない。キミは次のターンを失う。［弱体1］を受ける。", "大破（アーマー損傷）：フレームに甚大なダメージを受ける。以後、この部位の【部位装甲】に-3。［弱体1］を受ける。", "修復不能（フレーム崩壊）：フレームが［修復不能］となる。フレームの大部分が剥がれ落ち、ガラコの内部が晒される。以後、キミに対して部位狙いが行われる場合、その命中判定に対する修正（p21）は発生しなくなる。［弱体2］を受ける。"]}), "ADC": $hash2(["name", "table"], {"name": "部位ダメージチャート：アーム", "table": ["小破（アーマー損傷）：アームの装甲にヒビが入る。【部位装甲】-1。", "小破（武器落とし！）：【身体】8の判定を行う。失敗した場合、ダメージを受けた側のアームに（スロットを消費して）装着していた武器を落とす。【部位装甲】-1。", "小破（マニュピレータ損傷）：指が何本かちぎれ飛んだ。【操作性】-1、【部位装甲】-1。", "小破（機能停止）：次のターンの終了時まで、このアームを使った攻撃はできない。以後、この部位の【部位装甲】-1。", "中破（痙攣）：アームの動きがぶれ始める。［弱体1］を受ける。", "中破（武器落とし！）：ダメージを受けた側のアームに（スロットを消費して）装着していた武器を落とす。［弱体1］を受ける。", "中破（スピン）：機体が大きく回転する。【身体】10の判定を行うこと。失敗した場合、［伏せ］状態となった上、次のターンを失う。［弱体1］を受ける。", "大破（アーマー損傷）：以後、この部位の【部位装甲】を-3。［弱体1］を受ける。", "大破（武器落とし！）：ダメージを受けた側のアームに（スロットを消費して）装着していた武器を落とす。以後、この部位の【部位装甲】が0になる。［弱体1］を受ける。", "修復不能（破壊）：ダメージを受けた側のアームが［修復不能］となる。［弱体2］を受ける。"]}), "LDC": $hash2(["name", "table"], {"name": "部位ダメージチャート：レッグ", "table": ["小破（アーマー損傷）：以後、この部位の【部位装甲】-1。", "小破（よろめき）：以後、この部位の【部位装甲】-1。次のターン終了時まで、キミは移動できない。", "小破（スネア）：足元をすくわれる。【部位装甲】-1。さらに【身体】8の判定を行うこと。失敗した場合、キミは［伏せ］状態になる。", "小破（跛足）：以後、【移動力】-1、【部位装甲】-1。", "中破（シャフト損傷）：脚部の軸に歪みが生じる。［弱体1］を受ける。", "中破（アクチュエータ損傷）：脚部のアクチュエータに大きな損傷を受ける。【移動力】-1。［弱体1］を受ける。", "中破（スピン）：機体が大きく回転する。【身体】10の判定を行うこと。失敗した場合、［伏せ］状態となった上、次のターンを失う。［弱体1］を受ける。", "大破（アーマー損傷）：以後、この部位の【部位装甲】を-3。［弱体1］を受ける。", "大破（跛足）：以後、【移動力】-2。この部位の【部位装甲】が0になる。［弱体1］を受ける。", "修復不能（破壊）：ダメージを受けた側のレッグが［修復不能］となる。【移動力】-2。［弱体2］を受ける。"]})}).$freeze());
    Opal.const_set($nesting[0], 'TABLES', $hash2(["PNM", "PNF", "ENM", "ENF", "NNM", "NNF", "RNM", "RNF", "BN1", "BN2", "TN1", "TN2", "MTV", "HIT", "GCC", "WCC", "EVC", "BSD", "IDI"], {"PNM": $$($nesting, 'Table').$new("名前表：ピグマー族（男）", "1D10", ["バビロン", "グリニッジ", "デトロイト", "ヨコスカ", "ボルドー", "テキサス", "シチリア", "チェルノブイリ", "グンマ", "サマルトリア"]), "PNF": $$($nesting, 'Table').$new("名前表：ピグマー族（女）", "1D10", ["ルアンダ", "ローマ", "フロリダ", "ホノルル", "ツガル", "ゲルニカ", "シャンハイ", "モナコ", "チグリス", "オーサカ"]), "ENM": $$($nesting, 'Table').$new("名前表：エレメント族（男）", "1D10", ["アポロン", "ミキストリ", "アザゼル", "フマクト", "マサカド", "ククルカン", "ルシフェル", "ザギグ", "フェムト", "マイトレーヤ"]), "ENF": $$($nesting, 'Table').$new("名前表：エレメント族（女）", "1D10", ["クシナダ", "アルテミス", "ゼノビア", "フレイヤ", "イシュタム", "ベルゼバブ", "マイシェラ", "バステト", "スクルド", "アテナ"]), "NNM": $$($nesting, 'Table').$new("名前表：ノーマッド族（男）", "1D10", ["ドラム", "カホン", "ハレルヤ", "トリノウタ", "スリラー", "シンバル", "リュート", "ウクレレ", "タンバリン", "ユメコウネン"]), "NNF": $$($nesting, 'Table').$new("名前表：ノーマッド族（女）", "1D10", ["ピアノ", "テルミン", "ソバカス", "イマジン", "ツナミ", "ピッコロ", "ハープ", "シャミセン", "ミザルー", "ドナドナ"]), "RNM": $$($nesting, 'Table').$new("名前表：ラット族（男）", "1D10", ["ポチ", "シシマル", "ポンタ", "コテツ", "アルフォンス", "パトラッシュ", "ミッキー", "ジジ", "サカモト", "オンソクマル"]), "RNF": $$($nesting, 'Table').$new("名前表：ラット族（女）", "1D10", ["タマ", "ココ", "ラブ", "ピーコ", "モカ", "オリガミ", "ヒメ", "ミィ", "ルナ", "ク・メル"]), "BN1": $$($nesting, 'Table').$new("名前表：ブレイン族（その１）", "1D10", ["マリファナ", "バファリン", "タミフル", "セーロガン", "モルヒネ", "ハルシオン", "トリカブト", "バイアグラ", "エリクサー", "クラレ"]), "BN2": $$($nesting, 'Table').$new("名前表：ブレイン族（その２）", "1D10", ["ニトロ", "ダイオキシン", "タウリン", "コイーバ", "マールボロ", "キャメル", "ドクダミ", "アブサン", "ドブロク", "マティーニ"]), "TN1": $$($nesting, 'Table').$new("名前表：テンタクル族（その１）", "1D10", ["アップル", "プリン", "ビフテキ", "ガンモ", "レバニラ", "カボチャ", "コロッケ", "マトン", "ギョーザ", "タバスコ"]), "TN2": $$($nesting, 'Table').$new("名前表：テンタクル族（その２）", "1D10", ["キノコ", "セロリ", "ラザニア", "ユドーフ", "ニンジン", "カイワレ", "ボルシチ", "ハクサイ", "キャラメル", "ワタアメ"]), "MTV": $$($nesting, 'Table').$new("動機決定表", "1D10", ["金。お宝の臭いがした。", "正義。破界の塔は災いのもと。絶たねばならない。", "友情。この破界の塔のせいで友人が困っている。助けなくちゃ。", "探究心。破界の塔のことをもっと知りたい。", "戦闘狂。もっと戦いたい。", "暇つぶし。退屈な日常を忘れたい。", "自殺願望。なんかもう死にたい。", "冒険家。ワクワクしたい。", "山男。シティが肌に合わない。", "特に動機らしい動機はない。"]), "HIT": $$($nesting, 'Table').$new("部位決定チャート", "1D10", ["コックピット", "エンジン", "フレーム", "フレーム", "フレーム", "フレーム", "ライトアーム", "レフトアーム", "ライトレッグ", "レフトレッグ"]), "GCC": $$($nesting, 'Table').$new("ガラコ改造チャート表", "1D10", ["【命中+】価格+200。【操作性】+1。［不安定］1。", "【回避+】価格+200。【機動性】+1。［不安定］1。", "【視界+】価格+200。【視認性】+2。［不安定］1。", "【移動+】価格+100。【移動力】+1。", "【火力+】価格+200。その部位に装着した武器の火力を常に+2する。", "【部位装甲+】価格+100。【部位装甲】+2。", "【限界重量+】価格+100。【限界重量】+1000。", "【安定性+】価格+50。［不安定］-1。", "【スロット+】価格+500。【スロット】+1。", "【弱体無効】価格+500。このパーツへの部位ダメージによる[弱体]の効果を無視する。"]), "WCC": $$($nesting, 'Table').$new("武器改造チャート表", "1D10", ["【命中+】価格+200。【操作性】+1。", "【火力+】価格+200。【火力】+2。", "【射程】価格+200。【射程】+3。「射程：近接」の場合、「射程:3 or 近接」となる(攻撃する度にどちらかを選ぶ)。", "【範囲+】価格+200。1シーンにつき1回、この武器の目標を「範囲2」に変更してもよい(フリーアクション)。もともと範囲攻撃できる武器の場合は、「範囲n+1」にできる(1シーン1回、フリーアクション)。", "【部位変更】価格+200。装着できる部位がランダムに追加される。部位決定チャート(『GHT』p21)を使用して決めること。", "【部位装甲+】価格+100。装着した部位の【部位装甲】+2。", "【精度+】価格+100。この武器を使って狙い撃ちをする場合、命中判定に+1。", "【装飾+】価格+500。特に効果はないが、売却した時の金額が上昇する。", "【幸運+】価格+500。この武器による命中判定の出目が1だった場合、判定を振り直しても良い(1シーン1回まで)。", "【回数無限】価格+500。武器の使用回数制限がなくなる。"]), "EVC": $$($nesting, 'Table').$new("イベントチャート表", "1D10", ["【クリーチャー】スタートル(『GTD』p30)が1d10+3体現れる。戦闘開始。", "【ビット】コーンノーズ(『GTD』p23)が1d10+3体現れる。戦闘開始。", "【ノーマッド】ノーマッド族のランドクローラーと遭遇する。このシーンはノーマッドからアイテムを購入しても良い。ノーマッド族は天蓋都市で購入できるすべてのアイテムを販売している(ただし金額は20%増し)。", "【ピグマー族】君達の目的地方面から、ボロボロになったピグマー族のNPCが歩いてくる。NPCに何があったのかはGMが決めよ。ピグマー族を天蓋都市まで送った場合、謝礼として200クレジットを受け取ることが出来る。NPCは重量50のアイテムとして扱う。", "【ビット】ダスクウォッチ(『GTD』p23)が1d10+3体現れる。戦闘開始。", "【異常気象】嵐、竜巻、豪雨など、異常な気象によって行動を阻害される。PCのうち代表者1名が【視認】10の判定を行うこと。失敗した場合、次のシーンはスポットを移動できない。現在のスポットに留まることになる。", "【クリーチャー】ナグ(『GTD』p31)が1d10+4体現れる。戦闘開始。", "【ビット】ランオーバー(『GTD』p25)が3体現れる。戦闘開始。", "【猛毒の霧】付近に毒の霧が立ち込める。全てのキャラクターは毒によって1d10のHPダメージを受ける。", "【最悪の敵】ズルワーン(『GTD』p29)が1体現れる。戦闘開始。"]), "BSD": $$($nesting, 'Table').$new("戦闘開始距離", "1D10", ["3マス", "3マス", "6マス", "6マス", "9マス", "9マス", "12マス", "12マス", "15マス", "15マス"]), "IDI": $$($nesting, 'RangeTable').$new("個性表", "1D100", [[$range(1, 5, false), "〈近接武器熟練〉 近接攻撃の火力+1。"], [$range(6, 10, false), "〈遠隔武器熟練〉 遠隔攻撃の火力+1。"], [$range(11, 15, false), "〈天才〉 【技術】+1。"], [$range(16, 20, false), "〈頑強〉 【身体】+1。"], [$range(21, 25, false), "〈早業〉 【速度】+1。"], [$range(26, 30, false), "〈スイフトフット〉 【移動力】+1。"], [$range(31, 35, false), "〈超反応〉 行動判定値+2。"], [$range(36, 40, false), "〈警戒心〉 罠を発見するための判定に+2。"], [$range(41, 45, false), "〈解除屋〉 罠を解除するための判定に+2。"], [$range(46, 50, false), "〈タフガイ〉 最大HP+5。"], [51, "〈踏み込み〉 キミが使用する近接武器のデータを「射程：2」に変更する。"], [52, "〈不動〉 キミは強制移動の効果を受けない。"], [53, "〈ペイローダー〉 ガラコの【限界重量】+2000。"], [54, "〈魅力〉 キミがHPを回復するアイテム、もしくは超能力の目標になった時、キミのHPを追加で1点回復する。"], [55, "〈ダブルタップ〉 キミのターン開始時に使用。このターンの間、キミは追加で1回の遠隔攻撃を行うことができる。"], [56, "〈薙ぎ払い〉 キミのターン開始時に使用。このターンの間、キミが行う近接攻撃の目標を「周囲1マス以内にいるすべての敵」に変更する。"], [57, "〈武器落とし〉 キミは部位ひとつを指定する。目標は指定された部位に（スロットを消費して）装着している武器すべてを地面に落とす。"], [58, "〈切り払い〉 キミが行う回避判定の直前に使用。その判定を、【機動性】ではなく【操作性】で判定してよい。ただし、キミは近接武器を装着していなければならない。"], [59, "〈体崩しの達人〉 キミが目標のレッグに攻撃を命中させる度、その目標は【機動性】10の判定を行う。失敗した場合、目標は［伏せ］状態になる。"], [60, "〈超分解術〉 アイテムひとつを目標にする。目標のアイテムの重量を1/4にする。ただし、そのアイテムは使用できなくなる。再度〈超分解術〉の判定に成功することで、元に戻せる（重量が元に戻り、アイテムが使用可能になる）。"], [61, "〈即時換装〉 キミは、ガラコのパーツ換装を（ベースアクションではなく）ムーブアクションで行ってもよい。"], [62, "〈ノックバック〉 キミが目標に5点以上の最終ダメージを与えた直後に使用。目標を1マス、任意の方向に強制移動させる。近接武器で攻撃した場合のみ使用できる。"], [63, "〈照準〉 このターンの間、次に行う攻撃の命中判定+1。"], [64, "〈燃料節約術〉 戦闘時以外、キミは燃料を消費しなくてよい。"], [65, "〈追撃〉 キミの敵が、隣接するマスから離れるような移動を宣言した直後に使用。キミはその敵に対して近接攻撃を行う。近接攻撃の後、敵は移動を行うこと。"], [66, "〈連撃〉 キミが敵の部位を［修復不能］にした直後に使用。キミは再度、その敵に対して攻撃を行う。"], [67, "〈殺し屋〉 キミがコックピットに攻撃を命中させる度、そのガラコの操縦者は2点のHPを失う。"], [68, "〈極大射程〉 キミが扱う遠隔武器の射程を2倍にする。"], [69, "〈援護射撃〉 目標が回避判定を行った直後に使用。目標の回避判定の達成値-1。その後、キミは準備済みの遠隔武器ひとつの使用回数を1減らすこと。"], [70, "〈鉄壁〉 キミがダメージを受けた直後に使用。そのダメージを無効化する。"], [71, "〈心臓狙い〉 キミが部位狙いを行い、コックピット、もしくはエンジンに対して攻撃を行う際、命中判定+1。"], [72, "〈四肢狙い〉 キミが部位狙いを行い、アーム、もしくはレッグに対して攻撃を行う際、命中判定+1。"], [73, "〈窮地逆転〉 キミの判定の出目が1だった時、その出目を10に変更する。"], [74, "〈防御重視〉 ラウンド開始時に使用。【操作性】-1。【機動性】+2。ラウンド終了時まで。"], [75, "〈チアガール〉 目標は即座に追加のターンを得る。"], [76, "〈毒半減〉 キミが［毒］状態になった時、毎回失うHPを1点減らす。ノーマッド族はこの個性を取得できない。"], [77, "〈毒無効〉 キミは［毒］状態にならない。この個性はノーマッド族だけが取得できる。"], [78, "〈生存術〉 キミは各シーン終了時、HPを減らさなくてよい。"], [79, "〈平衡感覚〉 キミは［不安定］状態のペナルティを受けない。"], [80, "〈不屈〉 キミのターン開始時に使用。このターンの間、キミはガラコの損傷による［弱体］の効果を受けない。"], [81, "〈プレデターセンス〉 近接攻撃の命中判定+2。この個性はラット族だけが取得できる。"], [82, "〈鷹の目〉 遠隔攻撃の命中判定+2。この個性はラット族だけが取得できる。"], [83, "〈超リペア術〉 部位をひとつ選択する。目標の部位の被ダメージすべてを一時的に回復する（修復不能を除く）。回復したダメージは、シーン終了時に元に戻る（再度壊れる）。この個性はブレイン族のみが取得できる。"], [84, "〈浮遊術〉 キミは［飛行］状態になる。シーン終了時まで。この個性はテンタクル人のみが取得できる。"], [85, "〈瞬間移動術〉 キミは任意のマスに瞬間移動する。この個性はテンタクル人のみが取得できる。"], [86, "〈ハイボルテージ〉 4ラウンドめ以降、キミが持つすべての武器の火力を+2する。"], [87, "〈スライドディフェンス〉 キミが部位決定チャートを振った直後に使用。チャートの結果を+1する。"], [88, "〈カーブアタック〉 目標が部位決定チャートを振った直後に使用。チャートの結果を-1する。"], [89, "〈サイコショット〉 目標に［火力0］の攻撃を行う（自動命中）。（超能力）"], [90, "〈ファイア〉 目標に［火力5］の攻撃を行う。（超能力）"], [91, "〈アイス〉 目標に［火力3］の攻撃を行う。（超能力）"], [92, "〈サンダー〉 目標に［火力2］の攻撃を行う。（超能力）"], [93, "〈テレパシー〉 キミは念話によって会話することができる。（超能力）"], [94, "〈ミラー〉 目標が超能力の使用を宣言した直後に使用。超能力の目標を使用者自身に変更する。（超能力）"], [95, "〈バインド〉 目標のターン開始時に使用。目標の移動力-3。ターン終了時まで。（超能力）"], [96, "〈アーマー〉 目標のすべての部位装甲+2。シーン終了時まで。（超能力）"], [97, "〈バリア〉 目標がダメージを受けた直後に使用。ダメージを3点軽減する。（超能力）"], [98, "〈ヒール〉 目標のHPを［1d10-4］点回復する。出目が低いとHPを失う可能性があることに注意。（超能力）"], [99, "〈カース〉 目標が判定を行った直後に使用。その判定の達成値を-3する。"], [100, "〈リザレクション〉 死んだ目標を生き返らせる。生き返った目標のHPは10になる。このシーンの間に死亡したキャラクターのみ目標にできる。（超能力）"]])}).$freeze());
    return self.$setPrefixes($rb_plus(["GR.*", "(C|E|F|A|L)DC\\d+"], $$($nesting, 'TABLES').$keys()));
  })($nesting[0], $$($nesting, 'DiceBot'), $nesting);
})(Opal);
