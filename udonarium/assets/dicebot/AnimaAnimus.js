/* Generated by Opal 1.0.3 */
Opal.modules["utils/table"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$freeze', '$match', '$raise', '$to_i', '$[]', '$roll', '$-']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Table');

    var $nesting = [self].concat($parent_nesting), $Table_initialize$1, $Table_roll$2;

    self.$$prototype.times = self.$$prototype.sides = self.$$prototype.name = self.$$prototype.items = nil;
    
    
    Opal.def(self, '$initialize', $Table_initialize$1 = function $$initialize(name, type, items) {
      var self = this, m = nil;

      
      self.name = name;
      self.items = items.$freeze();
      m = /(\d+)D(\d+)/i.$match(type);
      if ($truthy(m)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + "Unexpected table type: " + (type))
      };
      self.times = m['$[]'](1).$to_i();
      return (self.sides = m['$[]'](2).$to_i());
    }, $Table_initialize$1.$$arity = 3);
    return (Opal.def(self, '$roll', $Table_roll$2 = function $$roll(bcdice) {
      var $a, $b, self = this, value = nil, index = nil;

      
      $b = bcdice.$roll(self.times, self.sides), $a = Opal.to_ary($b), (value = ($a[0] == null ? nil : $a[0])), $b;
      index = $rb_minus(value, self.times);
      return "" + (self.name) + "(" + (value) + ") ＞ " + (self.items['$[]'](index));
    }, $Table_roll$2.$$arity = 1), nil) && 'roll';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["utils/range_table"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy;

  Opal.add_stubs(['$new', '$alias_method', '$freeze', '$lambda', '$name', '$sum', '$content', '$attr_reader', '$match', '$raise', '$to_i', '$[]', '$store', '$find', '$include?', '$range', '$roll', '$map', '$split', '$to_proc', '$fetch', '$formatted=', '$-', '$private', '$coerce_to_int_range', '$sort_by', '$min', '$assert_min_sum_is_covered', '$assert_max_sum_is_covered', '$assert_no_gap_or_overlap_in_ranges', '$===', '$is_a?', '$begin', '$end', '$class', '$first', '$*', '$last', '$each_cons', '$max', '$+']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'RangeTable');

    var $nesting = [self].concat($parent_nesting), $RangeTable$1, $RangeTable$2, $RangeTable_initialize$3, $RangeTable_fetch$4, $RangeTable_roll$6, $RangeTable_store$7, $RangeTable_coerce_to_int_range$11, $RangeTable_assert_min_sum_is_covered$12, $RangeTable_assert_max_sum_is_covered$13, $RangeTable_assert_no_gap_or_overlap_in_ranges$14;

    self.$$prototype.name = self.$$prototype.items = self.$$prototype.num_of_dice = self.$$prototype.num_of_sides = self.$$prototype.formatter = nil;
    
    Opal.const_set($nesting[0], 'RollResult', $send($$($nesting, 'Struct'), 'new', ["sum", "values", "content", "formatted"], ($RangeTable$1 = function(){var self = $RangeTable$1.$$s || this;

    return self.$alias_method("to_s", "formatted")}, $RangeTable$1.$$s = self, $RangeTable$1.$$arity = 0, $RangeTable$1)));
    Opal.const_set($nesting[0], 'Item', $$($nesting, 'Struct').$new("range", "content"));
    Opal.const_set($nesting[0], 'DICE_ROLL_METHOD_RE', /^(\d+)D(\d+)$/i.$freeze());
    Opal.const_set($nesting[0], 'DEFAULT_FORMATTER', $send(self, 'lambda', [], ($RangeTable$2 = function(table, result){var self = $RangeTable$2.$$s || this;

    
      
      if (table == null) {
        table = nil;
      };
      
      if (result == null) {
        result = nil;
      };
      return "" + (table.$name()) + "(" + (result.$sum()) + ") ＞ " + (result.$content());}, $RangeTable$2.$$s = self, $RangeTable$2.$$arity = 2, $RangeTable$2)));
    self.$attr_reader("name");
    self.$attr_reader("num_of_dice");
    self.$attr_reader("num_of_sides");
    
    Opal.def(self, '$initialize', $RangeTable_initialize$3 = function $$initialize(name, dice_roll_method, items) {
      var $iter = $RangeTable_initialize$3.$$p, formatter = $iter || nil, $a, self = this, m = nil;

      if ($iter) $RangeTable_initialize$3.$$p = null;
      
      
      if ($iter) $RangeTable_initialize$3.$$p = null;;
      self.name = name.$freeze();
      self.formatter = ($truthy($a = formatter) ? $a : $$($nesting, 'DEFAULT_FORMATTER'));
      m = $$($nesting, 'DICE_ROLL_METHOD_RE').$match(dice_roll_method);
      if ($truthy(m)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + (self.name) + ": invalid dice roll method: " + (dice_roll_method))
      };
      self.num_of_dice = m['$[]'](1).$to_i();
      self.num_of_sides = m['$[]'](2).$to_i();
      return self.$store(items);
    }, $RangeTable_initialize$3.$$arity = 3);
    
    Opal.def(self, '$fetch', $RangeTable_fetch$4 = function $$fetch(value) {
      var $$5, self = this, item = nil;

      
      item = $send(self.items, 'find', [], ($$5 = function(i){var self = $$5.$$s || this;

      
        
        if (i == null) {
          i = nil;
        };
        return i.$range()['$include?'](value);}, $$5.$$s = self, $$5.$$arity = 1, $$5));
      if ($truthy(item)) {
      } else {
        self.$raise($$($nesting, 'RangeError'), "" + (self.name) + ": value is out of range: " + (value))
      };
      return item;
    }, $RangeTable_fetch$4.$$arity = 1);
    
    Opal.def(self, '$roll', $RangeTable_roll$6 = function $$roll(bcdice) {
      var $a, $b, self = this, sum = nil, values_str = nil, values = nil, result = nil, $writer = nil;

      
      $b = bcdice.$roll(self.num_of_dice, self.num_of_sides), $a = Opal.to_ary($b), (sum = ($a[0] == null ? nil : $a[0])), (values_str = ($a[1] == null ? nil : $a[1])), $b;
      values = $send(values_str.$split(","), 'map', [], "to_i".$to_proc());
      result = $$($nesting, 'RollResult').$new(sum, values, self.$fetch(sum).$content());
      
      $writer = [self.formatter['$[]'](self, result)];
      $send(result, 'formatted=', Opal.to_a($writer));
      $writer[$rb_minus($writer["length"], 1)];;
      return result;
    }, $RangeTable_roll$6.$$arity = 1);
    self.$private();
    
    Opal.def(self, '$store', $RangeTable_store$7 = function $$store(items) {
      var $$8, $$9, $$10, self = this, items_with_range = nil, sorted_items = nil;

      
      items_with_range = $send(items, 'map', [], ($$8 = function(r, c){var self = $$8.$$s || this;

      
        
        if (r == null) {
          r = nil;
        };
        
        if (c == null) {
          c = nil;
        };
        return [self.$coerce_to_int_range(r), c];}, $$8.$$s = self, $$8.$$arity = 2, $$8));
      sorted_items = $send(items_with_range, 'sort_by', [], ($$9 = function(r, _){var self = $$9.$$s || this;

      
        
        if (r == null) {
          r = nil;
        };
        
        if (_ == null) {
          _ = nil;
        };
        return r.$min();}, $$9.$$s = self, $$9.$$arity = 2, $$9));
      self.$assert_min_sum_is_covered(sorted_items);
      self.$assert_max_sum_is_covered(sorted_items);
      self.$assert_no_gap_or_overlap_in_ranges(sorted_items);
      self.items = $send(sorted_items, 'map', [], ($$10 = function(range, content){var self = $$10.$$s || this;

      
        
        if (range == null) {
          range = nil;
        };
        
        if (content == null) {
          content = nil;
        };
        return $$($nesting, 'Item').$new(range, content.$freeze()).$freeze();}, $$10.$$s = self, $$10.$$arity = 2, $$10)).$freeze();
      return self;
    }, $RangeTable_store$7.$$arity = 1);
    
    Opal.def(self, '$coerce_to_int_range', $RangeTable_coerce_to_int_range$11 = function $$coerce_to_int_range(x) {
      var $a, self = this, $case = nil;

      
      $case = x;
      if ($$($nesting, 'Integer')['$===']($case)) {return $$($nesting, 'Range').$new(x, x)}
      else if ($$($nesting, 'Range')['$===']($case)) {if ($truthy(($truthy($a = x.$begin()['$is_a?']($$($nesting, 'Integer'))) ? x.$end()['$is_a?']($$($nesting, 'Integer')) : $a))) {
        return x}};
      return self.$raise($$($nesting, 'TypeError'), "" + (self.name) + ": " + (x) + " (" + (x.$class()) + ") must be an Integer or a Range with Integers ");
    }, $RangeTable_coerce_to_int_range$11.$$arity = 1);
    
    Opal.def(self, '$assert_min_sum_is_covered', $RangeTable_assert_min_sum_is_covered$12 = function $$assert_min_sum_is_covered(sorted_items) {
      var self = this, min_sum = nil, range = nil;

      
      min_sum = self.num_of_dice;
      range = sorted_items.$first()['$[]'](0);
      if ($truthy(range['$include?'](min_sum))) {
      } else {
        self.$raise($$($nesting, 'RangeError'), "" + (self.name) + ": min value (" + (min_sum) + ") is not covered: " + (range))
      };
      return self;
    }, $RangeTable_assert_min_sum_is_covered$12.$$arity = 1);
    
    Opal.def(self, '$assert_max_sum_is_covered', $RangeTable_assert_max_sum_is_covered$13 = function $$assert_max_sum_is_covered(sorted_items) {
      var self = this, max_sum = nil, range = nil;

      
      max_sum = $rb_times(self.num_of_dice, self.num_of_sides);
      range = sorted_items.$last()['$[]'](0);
      if ($truthy(range['$include?'](max_sum))) {
      } else {
        self.$raise($$($nesting, 'RangeError'), "" + (self.name) + ": max value (" + (max_sum) + ") is not covered: " + (range))
      };
      return self;
    }, $RangeTable_assert_max_sum_is_covered$13.$$arity = 1);
    return (Opal.def(self, '$assert_no_gap_or_overlap_in_ranges', $RangeTable_assert_no_gap_or_overlap_in_ranges$14 = function $$assert_no_gap_or_overlap_in_ranges(sorted_items) {
      var $$15, self = this;

      
      $send(sorted_items, 'each_cons', [2], ($$15 = function(i1, i2){var self = $$15.$$s || this, r1 = nil, r2 = nil, max1 = nil, next_of_max1 = nil;
        if (self.name == null) self.name = nil;

      
        
        if (i1 == null) {
          i1 = nil;
        };
        
        if (i2 == null) {
          i2 = nil;
        };
        r1 = i1['$[]'](0);
        r2 = i2['$[]'](0);
        max1 = r1.$max();
        next_of_max1 = $rb_plus(max1, 1);
        if ($truthy(r2['$include?'](max1))) {
          self.$raise($$($nesting, 'RangeError'), "" + (self.name) + ": Range overlap: " + (r1) + " and " + (r2))};
        if ($truthy(r2['$include?'](next_of_max1))) {
          return nil
        } else {
          return self.$raise($$($nesting, 'RangeError'), "" + (self.name) + ": Range gap: " + (r1) + " and " + (r2))
        };}, $$15.$$s = self, $$15.$$arity = 2, $$15));
      return self;
    }, $RangeTable_assert_no_gap_or_overlap_in_ranges$14.$$arity = 1), nil) && 'assert_no_gap_or_overlap_in_ranges';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.0.3 */
Opal.modules["utils/ArithmeticEvaluator"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$tokenize', '$expr', '$private', '$split', '$gsub', '$mul', '$loop', '$consume', '$+', '$-', '$unary', '$*', '$div', '$zero?', '$===', '$ceil', '$/', '$to_f', '$round', '$floor', '$-@', '$term', '$expect', '$expect_number', '$!=', '$[]', '$integer?', '$to_i', '$!', '$nil?', '$match']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'ArithmeticEvaluator');

    var $nesting = [self].concat($parent_nesting), $ArithmeticEvaluator_eval$1, $ArithmeticEvaluator_tokenize$2, $ArithmeticEvaluator_add$4, $ArithmeticEvaluator_mul$6, $ArithmeticEvaluator_div$8, $ArithmeticEvaluator_unary$9, $ArithmeticEvaluator_term$10, $ArithmeticEvaluator_consume$11, $ArithmeticEvaluator_expect$12, $ArithmeticEvaluator_expect_number$13, $ArithmeticEvaluator_integer$ques$14;

    self.$$prototype.error = self.$$prototype.round_type = self.$$prototype.tokens = self.$$prototype.idx = nil;
    
    
    Opal.def(self, '$eval', $ArithmeticEvaluator_eval$1 = function(expr, round_type) {
      var self = this, ret = nil;

      
      
      if (round_type == null) {
        round_type = "omit";
      };
      self.tokens = self.$tokenize(expr);
      self.idx = 0;
      self.error = false;
      self.round_type = round_type;
      ret = self.$expr();
      if ($truthy(self.error)) {
        return 0
      } else {
        return ret
      };
    }, $ArithmeticEvaluator_eval$1.$$arity = -2);
    self.$private();
    
    Opal.def(self, '$tokenize', $ArithmeticEvaluator_tokenize$2 = function $$tokenize(expr) {
      var $$3, self = this;

      return $send(expr, 'gsub', [/[\(\)\+\-\*\/]/], ($$3 = function(e){var self = $$3.$$s || this;

      
        
        if (e == null) {
          e = nil;
        };
        return "" + " " + (e) + " ";}, $$3.$$s = self, $$3.$$arity = 1, $$3)).$split(" ")
    }, $ArithmeticEvaluator_tokenize$2.$$arity = 1);
    
    Opal.def(self, '$add', $ArithmeticEvaluator_add$4 = function $$add() {
      var $$5, self = this, ret = nil;

      
      ret = self.$mul();
      (function(){var $brk = Opal.new_brk(); try {return $send(self, 'loop', [], ($$5 = function(){var self = $$5.$$s || this;

      if ($truthy(self.$consume("+"))) {
          return (ret = $rb_plus(ret, self.$mul()))
        } else if ($truthy(self.$consume("-"))) {
          return (ret = $rb_minus(ret, self.$mul()))
        } else {
          
          Opal.brk(nil, $brk)
        }}, $$5.$$s = self, $$5.$$brk = $brk, $$5.$$arity = 0, $$5))
      } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
      return ret;
    }, $ArithmeticEvaluator_add$4.$$arity = 0);
    Opal.alias(self, "expr", "add");
    
    Opal.def(self, '$mul', $ArithmeticEvaluator_mul$6 = function $$mul() {
      var $$7, self = this, ret = nil;

      
      ret = self.$unary();
      (function(){var $brk = Opal.new_brk(); try {return $send(self, 'loop', [], ($$7 = function(){var self = $$7.$$s || this;

      if ($truthy(self.$consume("*"))) {
          return (ret = $rb_times(ret, self.$unary()))
        } else if ($truthy(self.$consume("/"))) {
          return (ret = self.$div(ret, self.$unary()))
        } else {
          
          Opal.brk(nil, $brk)
        }}, $$7.$$s = self, $$7.$$brk = $brk, $$7.$$arity = 0, $$7))
      } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
      return ret;
    }, $ArithmeticEvaluator_mul$6.$$arity = 0);
    
    Opal.def(self, '$div', $ArithmeticEvaluator_div$8 = function $$div(left, right) {
      var self = this, $case = nil;

      
      if ($truthy(right['$zero?']())) {
        
        self.error = true;
        return 0;};
      return (function() {$case = self.round_type;
      if ("roundUp"['$===']($case)) {return $rb_divide(left.$to_f(), right).$ceil()}
      else if ("roundOff"['$===']($case)) {return $rb_divide(left.$to_f(), right).$round()}
      else {return $rb_divide(left, right).$floor()}})();
    }, $ArithmeticEvaluator_div$8.$$arity = 2);
    
    Opal.def(self, '$unary', $ArithmeticEvaluator_unary$9 = function $$unary() {
      var self = this;

      if ($truthy(self.$consume("+"))) {
        return self.$unary()
      } else if ($truthy(self.$consume("-"))) {
        return self.$unary()['$-@']()
      } else {
        return self.$term()
      }
    }, $ArithmeticEvaluator_unary$9.$$arity = 0);
    
    Opal.def(self, '$term', $ArithmeticEvaluator_term$10 = function $$term() {
      var self = this, ret = nil;

      if ($truthy(self.$consume("("))) {
        
        ret = self.$expr();
        self.$expect(")");
        return ret;
      } else {
        return self.$expect_number()
      }
    }, $ArithmeticEvaluator_term$10.$$arity = 0);
    
    Opal.def(self, '$consume', $ArithmeticEvaluator_consume$11 = function $$consume(str) {
      var self = this;

      
      if ($truthy(self.tokens['$[]'](self.idx)['$!='](str))) {
        return false};
      self.idx = $rb_plus(self.idx, 1);
      return true;
    }, $ArithmeticEvaluator_consume$11.$$arity = 1);
    
    Opal.def(self, '$expect', $ArithmeticEvaluator_expect$12 = function $$expect(str) {
      var self = this;

      
      if ($truthy(self.tokens['$[]'](self.idx)['$!='](str))) {
        self.error = true};
      return (self.idx = $rb_plus(self.idx, 1));
    }, $ArithmeticEvaluator_expect$12.$$arity = 1);
    
    Opal.def(self, '$expect_number', $ArithmeticEvaluator_expect_number$13 = function $$expect_number() {
      var self = this, ret = nil;

      
      if ($truthy(self['$integer?'](self.tokens['$[]'](self.idx)))) {
      } else {
        
        self.error = true;
        self.idx = $rb_plus(self.idx, 1);
        return 0;
      };
      ret = self.tokens['$[]'](self.idx).$to_i();
      self.idx = $rb_plus(self.idx, 1);
      return ret;
    }, $ArithmeticEvaluator_expect_number$13.$$arity = 0);
    return (Opal.def(self, '$integer?', $ArithmeticEvaluator_integer$ques$14 = function(str) {
      var self = this;

      return /^\d+$/.$match(str)['$nil?']()['$!']()
    }, $ArithmeticEvaluator_integer$ques$14.$$arity = 1), nil) && 'integer?';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.0.3 */
(function(Opal) {
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice, $klass = Opal.klass, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2, $range = Opal.range;

  Opal.add_stubs(['$require', '$===', '$check_action', '$last_match', '$roll_tables', '$new', '$eval', '$[]', '$debug', '$roll', '$map', '$split', '$to_proc', '$count', '$<=', '$include?', '$+', '$>', '$freeze', '$setPrefixes', '$keys']);
  
  self.$require("utils/table.rb");
  self.$require("utils/range_table");
  self.$require("utils/ArithmeticEvaluator");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'AnimaAnimus');

    var $nesting = [self].concat($parent_nesting), $AnimaAnimus_initialize$1, $AnimaAnimus_rollDiceCommand$2, $AnimaAnimus_check_action$3;

    
    Opal.const_set($nesting[0], 'ID', "AnimaAnimus");
    Opal.const_set($nesting[0], 'NAME', "アニマアニムス");
    Opal.const_set($nesting[0], 'SORT_KEY', "あにまあにむす");
    Opal.const_set($nesting[0], 'HELP_MESSAGE', "" + "・行為判定(xAN<=y±z)\n" + "　十面ダイスをx個振って判定します。達成値が算出されます(クリティカル発生時は2増加)。\n" + "　x：振るダイスの数。魂魄値や攻撃値。\n" + "　y：成功値。\n" + "　z：成功値への補正。省略可能。\n" + "　(例) 2AN<=3+1 5AN<=7\n" + "・各種表\n" + "　情報収集表　IGT/喪失表　LT\n");
    
    Opal.def(self, '$initialize', $AnimaAnimus_initialize$1 = function $$initialize() {
      var $iter = $AnimaAnimus_initialize$1.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $AnimaAnimus_initialize$1.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      $send(self, Opal.find_super_dispatcher(self, 'initialize', $AnimaAnimus_initialize$1, false), $zuper, $iter);
      return (self.sendMode = 2);
    }, $AnimaAnimus_initialize$1.$$arity = 0);
    
    Opal.def(self, '$rollDiceCommand', $AnimaAnimus_rollDiceCommand$2 = function $$rollDiceCommand(command) {
      var self = this, $case = nil;

      return (function() {$case = command;
      if (/(\d+)AN<=(\d+([\+\-]\d+)*)/i['$===']($case)) {return self.$check_action($$($nesting, 'Regexp').$last_match())}
      else {return self.$roll_tables(command, $$($nesting, 'TABLES'))}})()
    }, $AnimaAnimus_rollDiceCommand$2.$$arity = 1);
    
    Opal.def(self, '$check_action', $AnimaAnimus_check_action$3 = function $$check_action(match_data) {
      var $a, $b, $$4, self = this, a = nil, dice_cnt = nil, target = nil, _ = nil, dice_str = nil, dice_arr = nil, suc_cnt = nil, has_critical = nil, result = nil;

      
      a = $$($nesting, 'ArithmeticEvaluator').$new();
      dice_cnt = a.$eval(match_data['$[]'](1));
      target = a.$eval(match_data['$[]'](2));
      self.$debug("dice_cnt", dice_cnt);
      self.$debug("target", target);
      $b = self.$roll(dice_cnt, 10), $a = Opal.to_ary($b), (_ = ($a[0] == null ? nil : $a[0])), (dice_str = ($a[1] == null ? nil : $a[1])), $b;
      dice_arr = $send(dice_str.$split(","), 'map', [], "to_i".$to_proc());
      suc_cnt = $send(dice_arr, 'count', [], ($$4 = function(x){var self = $$4.$$s || this;

      
        
        if (x == null) {
          x = nil;
        };
        return $rb_le(x, target);}, $$4.$$s = self, $$4.$$arity = 1, $$4));
      has_critical = dice_arr['$include?'](1);
      result = (function() {if ($truthy(has_critical)) {
        return $rb_plus(suc_cnt, 2)
      } else {
        return suc_cnt
      }; return nil; })();
      return "" + "(" + (dice_cnt) + "B10<=" + (target) + ") ＞ " + (dice_str) + " ＞ " + ((function() {if ($truthy($rb_gt(result, 0))) {
        return "成功"
      } else {
        return "失敗"
      }; return nil; })()) + "(達成値:" + (result) + ")" + ((function() {if ($truthy(has_critical)) {
        return " (クリティカル発生)"
      } else {
        return ""
      }; return nil; })());
    }, $AnimaAnimus_check_action$3.$$arity = 1);
    Opal.const_set($nesting[0], 'TABLES', $hash2(["IGT", "LT"], {"IGT": $$($nesting, 'Table').$new("情報収集表", "1d10", ["ストリートファイト/<格闘>/「俺に勝てたら教えてやるよ」情報を知る魂願者から勝負を挑まれた。生き延びるためにもこの勝負、負けるわけにはいかない。", "追跡！/<追跡／逃走>/有益な情報を持っている人間を見つけたが、こちらの顔を見るなり逃げ出した。どうにかして捕まえなくてはならない。", "脅し/<威圧>/ならず者たちが集まるバーにやってきた。裏社会に生きる彼らを脅せば有益な情報が手に入るはずだ。", "インターネット/<コンピュータ>/SNSやニュースなど、インターネット上の情報を調査する。デマには騙されないようにしなくては。", "瀕死の情報提供者/<医学>/情報を知る人物がいると聞いてやってきたら、その人物が瀕死の重傷を負っていた。なんとかして蘇生させなくては。", "潜入捜査/<隠密>/敵対する魂願者たちのグループに潜り込んでの調査活動。リスクは高いが、有益な情報が手に入る確率は高い。", "情報交換/<交渉>/友好的な関係にある魂願者との情報交換。うまく話を聞き出すことができるとよいが。", "魔宴の情報屋/<調達>/魔宴の情報屋に接触して情報を聞き出すことにした。一筋縄ではいかない相手らしいが、はたして……？", "違法調査/<犯罪>/法に触れるやり方で情報を集めることにした。ハッキング、窃盗、恐喝、どんな手段を選ぼうか。", "聞き込み/<自我>/街ゆく人びとに聞き込みを行なう。地道な活動こそが目標にたどり着くための最短の方法だ。"]), "LT": $$($nesting, 'RangeTable').$new("喪失表", "1d10", [[$range(1, 2, false), "存在/存在が希薄になり、知り合いや友人に自分の存在を忘れられてしまう。いずれ大切なパートナーの記憶からも消え、この世界でひとりぼっちになる。\nあなたの出自を消去すること。"], [$range(3, 4, false), "記憶/自分の大切な記憶をひとつ失なう。これからは力を使うたびに記憶をひとつ失なうことになり、最後には大切なパートナーのことも思い出せなくなってしまう。\nあなたのメモリアをひとつ選択して消去すること。シナリオメモリアは選択できない。"], [$range(5, 6, false), "容姿/だんだんと以前とはかけ離れた姿に変わっていく。いずれ誰も自分のことを自分だと気づかなくなるのだろう。\nあなたの特徴的な外見を失なう。内容をふさわしいものに書き換えること(特徴的な外見が美しい髪であれば醜い髪など)。"], [$range(7, 8, false), "感情/喜怒哀楽の感情のうち、いずれかひとつを失なう。力を使うたびに他の感情も失っていき、最後にはただ生き残るために戦う機械となる。\nポジティブかネガティブのどちらかを選択する。選択した感情をすべてのメモリアから消去する。消去した結果、表出感情がなくなってしまった場合、残った感情を表出感情にすること。なお、新しくメモリアを取得した場合も、選んだ感情を得ることはできない。"], [$range(9, 10, false), "五感/少しずつ五感が鈍くなる。今までできていたはずのことができなくなってしまう。\nあなたの特技をひとつ選択する。選択した特技に×をつけること。×が付いた技能で判定を行なうことはできず、判定を求められた場合は自動的に失敗となる。"]])}).$freeze());
    return self.$setPrefixes($rb_plus(["\\d+AN<=\\d([\\+\\-]\\d+)*"], $$($nesting, 'TABLES').$keys()));
  })($nesting[0], $$($nesting, 'DiceBot'), $nesting);
})(Opal);
